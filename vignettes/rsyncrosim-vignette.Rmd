---
title: "Introduction to rsyncrosim"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to rsyncrosim}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

This vignette will cover the basics of using the `rsyncrosim` package within the <a href="https://syncrosim.com/" target="_blank">SyncroSim</a> software framework. Specifically, we will cover the following topics:

* [Overview of SyncroSim](#overview-of-syncroSim)
* [Overview of rsyncrosim](#overview-of-rsyncrosim)
* [Package: helloworldEnhanced](#package-helloworldenhanced)
* [Setup](#setup)
* [Create a model](#create-a-model)
* [Edit a model](#edit-a-model)
* [Run a model](#run-a-model)
* [View results](#view-results)
* [Access model metadata](#access-model-metadata)
* [Backup your Library](#backup-your-ibrary)


## Overview of SyncroSim


<a href="https://syncrosim.com/" target="_blank">SyncroSim</a> is a software platform that helps you turn your *data* into *forecasts*. At the core of SyncroSim is an engine that automatically structures your existing data, regardless of its original format. SyncroSim transforms this structured data into forecasts by running it through a pipeline of calculations (i.e. a suite of *models*). Finally, SyncroSim  provides a rich interface to interact with your data and models, allowing you to explore and track the consequences of alternative "what-if" forecasting scenarios. Within this software framework is the ability to use and create <a href="https://docs.syncrosim.com/how_to_guides/package_overview.html" target="_blank">SyncroSim packages</a>.  

For more details consult the SyncroSim <a href="https://docs.syncrosim.com/" target="_blank">online documentation</a>.


## Overview of rsyncrosim


`rsyncrosim` is an R package designed to facilitate the development of modeling workflows for the <a href="https://syncrosim.com/" target="_blank">SyncroSim</a> software framework. Using the `rsyncrosim` interface, simulation models can be added and run through SyncroSim to transform scenario-based datasets into model forecasts. This R package takes advantage of general features of SyncroSim, such as defining scenarios with spatial or non-spatial inputs, running Monte Carlo simulations, and summarizing model outputs. `rsyncrosim` requires SyncroSim 2.2.13 or higher.

For more details consult the `rsyncrosim` <a href="https://cran.r-project.org/web/packages/rsyncrosim/index.html" target="_blank">CRAN documentation</a>.

## SyncroSim Package: helloworldEnhanced


To demonstrate the utility of the `rsyncrosim` interface, we will be using the <a href="https://github.com/ApexRMS/helloworldEnhanced" target="_blank">helloworldEnhanced</a> SyncroSim package. `helloworldEnhanced` was designed to be a simple package to show off some key functionalities of SyncroSim, including the ability to use timesteps, Monte Carlo realizations, both spatial and non-spatial data, and pipelines to link sequential models.

The package takes 3 inputs, including a spatial raster file, from the user and runs these values through 2 models to produce outputs. The package also includes the ability to use iterations, so the user can run the pipeline of models multiple times to get a measure of uncertainty.

![Infographic of helloworldEnhanced package](./infographic.png)

For more details on the different features of the `helloworldEnhanced` SyncroSim package, consult the SyncroSim <a href="https://docs.syncrosim.com/how_to_guides/package_create_timesteps.html" target="_blank">Enhancing a Package tutorial</a>.


## Setup


### Install SyncroSim

Before using `rsyncrosim` you will first need to <a href="https://syncrosim.com/download/" target="_blank">download and install</a> the SyncroSim software. Versions of SyncroSim exist for both Windows and Linux.

### Installing and loading R packages

You will need to install the `rsyncrosim` R package, either using <a href="https://cran.r-project.org/" target="_blank">CRAN</a> or from the `rsyncrosim` <a href="https://github.com/syncrosim/rsyncrosim/releases/" target="_blank">GitHub repository</a>. Versions of `rsyncrosim` are available for both Windows and Linux.

In a new R script, load the necessary packages. This includes the `rsyncrosim`, `raster`, and `this.path` R packages. You may need to install the `raster` and `rgdal` packages from CRAN as well.

```{r, warning = FALSE, message = FALSE}
# Load R packages
library(rsyncrosim)  # package for working with SyncroSim
library(raster)      # package for working with raster data
```

### Installing SyncroSim packages using `addPackage()`

Check if the <a href="https://github.com/ApexRMS/helloworldEnhanced" target="_blank">helloworldEnhanced</a> package is already installed. Use the `package()` function from `rsyncrosim` to first get a list of all currently installed packages in SyncroSim.

```{r, echo = FALSE, results = FALSE}
if (is.element("demosales", package()$name)) deletePackage("demosales")
if (is.element("dgsim", package()$name)) deletePackage("dgsim")
if (is.element("epi", package()$name)) deletePackage("epi")
if (is.element("helloworld", package()$name)) deletePackage("helloworld")
if (is.element("helloworldEnhanced", package()$name)) deletePackage("helloworldEnhanced")
if (is.element("landfirevegmodels", package()$name)) deletePackage("landfirevegmodels")
if (is.element("stsim", package()$name)) deletePackage("stsim")
if (is.element("stsimsf", package()$name)) deletePackage("stsimsf")
```


```{r, warning = FALSE}
# Get list of installed packages
package()
```

Currently we do not have any packages installed! Install `helloworldEnhanced` using the `rynscrosim` function `addPackage()`. This function takes a package name as input and then queries the SyncroSim package server for the specified package.

```{r, warning = FALSE, eval = FALSE}
# Install helloworldEnhanced
addPackage("helloworldEnhanced")
```

To install the package from a `.ssimpkg` file on your local computer rather than installing directly from the server, you can use the `addPackageFile()` function. Instead of using the package name as the argument, the file path to the `.ssimpkg` is used.

```{r, warning = FALSE, eval = FALSE}
# Install helloworldEnhanced using file path to ssimpkg file
addPackageFile("path/to/helloworldEnhanced.ssimpkg")
```

```{r, echo = FALSE, results = FALSE}
addPackageFile("c:\\Users\\birch\\OneDrive\\Desktop\\install\\helloworldEnhanced.ssimpkg")
```


Now `helloworldEnhanced` should be included in the package list:

```{r, warning = FALSE}
# Get list of installed packages
myInstalledPackages = package()
is.element("helloworldEnhanced", myInstalledPackages$name)
```


*Note:* you can also update installed packages using the `updatePackage()` function or delete installed packages using the `deletePackage()` function in `rsyncrosim`

### Connecting R to SyncroSim using `session()`

The final step in setting up the R environment for the `rsyncrosim` workflow is to create a SyncroSim Session object in R that provides the connection to your installed copy of the SyncroSim software. A new Session is created using the `session()` function, in which the first argument is a path to the folder on your computer where SyncroSim has been installed. If the first argument is left blank, then the default install folder is used (Windows only).

```{r, warning = FALSE, eval = FALSE}
mySession <- session("path/to/install_folder")      # Create a Session based SyncroSim install folder
mySession <- session()                              # Using default install folder (Windows only)
mySession                                           # Displays the Session object
```

```{r, echo = FALSE}
mySession <- session()
mySession
```


You can check to see which version of SyncroSim your R script is connected to by running the `version()` function.

```{r, warning = FALSE}
version(mySession)
```


## Create a model


When creating a new model from scratch, we need to create objects of the following scopes:

* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Library</a>
* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Projects</a>
* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Scenarios</a>

These objects are hierarchical, such that a Library can contain many projects, and each Project can contain many scenarios. All parameters or configurations set in a Library are inherited by all projects within the Library, and all parameters or configurations set in a Project are inherited by all scenarios within that Project. See below for further information on these model objects.

### Create a new library using `ssimLibrary()`

A SyncroSim <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Library</a> is a file (with `.ssim` extension) that stores all of your model inputs and outputs. The format of each SyncroSim Library is unique to the SyncroSim Package with which it is associated. We use the `ssimLibrary()` function to create a new SsimLibrary object in R that is connected (through your Session) to a SyncroSim Library file. Note that an existing Library file can be later opened again by setting `overwrite=FALSE` for the `ssimLibrary()` function.

```{r, warning = FALSE}
# Create a new library
myLibrary <- ssimLibrary(name = "helloworldLibrary.ssim",
                         session = mySession,
                         package = "helloworldEnhanced",
                         overwrite = TRUE)

# Check library information
myLibrary
```

### Create a new project using `project()`

Each SyncroSim Library contains one or more SyncroSim <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Projects</a>, each represented by a Project object in R. Projects typically store model inputs that are common to all your scenarios. In most situations you will need only a single Project for your Library; by default each new Library starts with a single Project named "Definitions" (with a unique `projectId`= 1). The `project()` function is used to both create and retrieve Projects. Note that the `ssimObject` here can be the name of a Library or Scenario.

```{r, warning = FALSE}
# Create a new project
myProject = project(ssimObject = myLibrary, project = "Definitions")  # Using name for Project
myProject = project(ssimObject = myLibrary, project = 1)              # Using projectId for Project

# Check project information
myProject
```


### Create a new scenario using `scenario()`

Finally, each SyncroSim Project contains one or more <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Scenarios</a>, each represented by a Scenario object in R. Scenarios store the specific model inputs and outputs associated with each model run in SyncroSim. Each Scenario can be identified by its unique `scenarioId`. The `scenario()` function is used to both create and retrieve Scenarios. Note that the `ssimObject` here can be the name of a Library or a Project.

```{r, warning = FALSE}
# Create a new scenario (associated with the default Project)
myScenario = scenario(ssimObject = myProject, scenario = "My first scenario")

# Check scenario information
myScenario
```

### View model inputs using `datasheet()`
  
Each SyncroSim Library contains multiple SyncroSim <a href="https://docs.syncrosim.com/how_to_guides/properties_overview.html" target="_blank">Datasheets</a>. A SyncroSim Datasheet is simply a table of data stored in the Library. Datasheets each have a *scope*: either library, project or scenario. We can view Datasheets of varying scopes using the `datasheet()` function from `rsyncrosim`. We set the `summary` parameter to `TRUE` to get a single dataframe of all Datasheet names in the `ssimObject`.

```{r, warning = FALSE}
# View all datasheets associated with a Library
datasheet(myLibrary, summary = TRUE)

# View all datasheets associated with a project
datasheet(myProject, summary = TRUE)

# View all datasheets associated with a scenario
datasheet(myScenario, summary = TRUE)
```

If we set `summary` to `FALSE`, we get a list of dataframes, each corresponding to a Datasheet in the `ssimObject`.

```{r, warning = FALSE, message = FALSE, eval = FALSE}
# View all datasheets associated with a scenario when summary is FALSE
datasheet(myLibrary, summary = FALSE)
```

You will notice that if the `ssimObject` in the `datasheet()` function is a scenario, then all the datasheets for that scenario, the parent project, and the parent library are returned. If you only want to see the datasheets for a given scenario, then you can use the base R function, `subset()`, with scope set to "scenario".

```{r, warning = FALSE}
subset(datasheet(myScenario, summary = TRUE), scope == "scenario")
```

To view a specific datasheet rather than just a dataframe of available datasheets, set the `name` parameter in the `datasheet()` function to the name of the datasheet you want to view. The general syntax of the name is: "<name of package>_<name of datasheet>". From the list of datasheets above, we can see that there are 4 datasheets specific to the `helloworldEnhanced` package.

```{r, warning = FALSE}
# View the input datasheet for the scenario
datasheet(myScenario, name = "helloworldEnhanced_InputDatasheet")
```

### Configure model inputs using `datasheet()` and `addRow()`

Currently our input scenario datasheets are empty! We need to add some values to our input datasheet (`InputDatasheet`) and our run control datasheet (`RunControl`) so we can run our model. The `InputDatasheet` specifies the model inputs, whereas the `RunControl` datasheet provides information about how many timesteps and iterations to use. We also need to add some information to the `Pipeline` datasheet from the built-in SyncroSim Core, as this is where we specify which models (AKA transformers) should be run in which order. First, assign the input and run control datasheets to new variables.

```{r, warning = FALSE}
# Assign input datasheet to a new variable
inputDf <- datasheet(myScenario, name = "helloworldEnhanced_InputDatasheet")

# Assign run control datasheet to a new variable
runControlDf <- datasheet(myScenario, name = "helloworldEnhanced_RunControl")

# Assign pipeline datasheet to a new variable
pipelineDf <- datasheet(myScenario, name = "core_Pipeline")
```

Now, check the columns that need input values and the type of values these columns require (e.g. string, numeric, logical) using the `str()` base function.

```{r, warning = FALSE}
# Check the columns of the input datasheet
str(inputDf)

# Check the columns of the run control datasheet
str(runControlDf)

# Check the columns of the pipeline datasheet
str(pipelineDf)
```

The input datasheet requires 3 values:

* `mMean` : the mean of a normal distribution that will determine the slope of the linear equation.
* `mSD` : the standard deviation of a normal distribution that will determine the slope of the linear equation.
* `InterceptRasterFileName` : the filepath to a raster image, in which each cell of the image will be an intercept in the linear equation.

We can add these values to a new dataframe, then use the `addRow()` function from `rsyncrosim` to update the input datasheet. The `addRow()` function takes the `targetDataframe` as the first value (in this case, our input datasheet that we want to update), and the new rows to append to this dataframe as the second value.

```{r, warning = FALSE, eval = TRUE}
# Create input data and add it to the input datasheet
inputRow <- data.frame(mMean = 0, mSD = 4,
                       InterceptRasterFileName = "path/to/raster-image.tif")
inputDf <- addRow(inputDf, inputRow)

# Check values
inputDf
```

```{r, warning = FALSE, echo = FALSE}
# Create input data and add it to the input datasheet
inputDf <- data.frame(
  mMean = 0, mSD = 4,
  InterceptRasterFileName = "C:\\gitprojects\\helloworldEnhanced\\step5_Spatial\\input-raster.tif")
```

We also need to set the number of iterations and the minimum and maximum timesteps for our model. We'll add this information to a dataframe as well and then add it to the Run Control datasheet using `addRow()`. We need to specify data for the following 4 columns:

* `MinimumIteration` : starting value of iterations (default=1).
* `MaximumIteration` : total number of iterations to run the model for.
* `MinimumTimestep` : the starting time point of the simulation.
* `MaximumTimestep` : the end time point of the simulation.

```{r, warning = FALSE}
# Create run control data and add it to the run control datasheet
runControlRow <- data.frame(MinimumIteration = 1,
                            MaximumIteration = 5,
                            MinimumTimestep = 1,
                            MaximumTimestep = 10)
runControlDf <- addRow(runControlDf, runControlRow)

# Check values
runControlDf
```

Finally, we need to specify the order in which to run the two models in our pipeline by editing the pipeline datasheet. Note that from viewing the pipeline datasheet we know that the `StageNameID` is a factor with 2 levels: "First Model" and "Second Model". We will set the data for this datasheet such that "First Model" is run first, and then "Second Model".

```{r}
# Create pipeline data and add it to the pipeline datasheet
pipelineRow <- data.frame(StageNameID = c("First Model", "Second Model"),
                          RunOrder = c(1, 2))

pipelineDf <- addRow(pipelineDf, pipelineRow)

# Check values
pipelineDf
```


### Saving modifications to datasheets using `saveDatasheet()`

Now that we have added values to the input datasheets, we will save our updated datasheets to the Library, Project, and/or Scenario using the `saveDatasheets()` function.

```{r, warning = FALSE}
# Save input datasheet
saveDatasheet(ssimObject = myScenario, data = inputDf,
              name = "helloworldEnhanced_InputDatasheet")

# Save run control datasheet
saveDatasheet(ssimObject = myScenario, data = runControlDf,
              name = "helloworldEnhanced_RunControl")

# Save pipeline datasheet
saveDatasheet(ssimObject = myScenario, data = pipelineDf,
              name = "core_Pipeline")
```

## Edit a model


You may want to test multiple alternative scenarios that have slightly different inputs. To save time, you can copy a scenario that you've already made, give it a different name, and modify the inputs. To copy a completed scenario, use the `scenario()` function with the `sourceScenario` argument set to the name of the scenario you want to copy.

```{r, warning = FALSE}
# Check which scenarios you currently have in your library
scenario(myLibrary)['name']

# Create a new scenario based off an old scenario
myNewScenario <- scenario(ssimObject = myProject,
                          scenario = "My second scenario",
                          sourceScenario = myScenario)

# Make sure this new scenario has been added to the library
scenario(myLibrary)['name']
```


To edit the new scenario, we must first load the datasheet and assign it to a new variable using the `datasheet()` function. We will set the `empty` argument to `TRUE` so that instead of getting the values from the old scenario, we can add a dataframe of new values.

```{r, warning = FALSE}
# Load empty input datasheet
newInputDf <- datasheet(myNewScenario,
                        name = "helloworldEnhanced_InputDatasheet",
                        empty=TRUE)

# Check that we have an empty datasheet
str(newInputDf)
```

Now, all we need to do is add our dataframe of values the same way we did before, using the `addRow()` function.

```{r, warning = FALSE}
# Create input data and add it to the input datasheet
newInputRow <- data.frame(mMean = 2, mSD = 8,
                          InterceptRasterFileName = "path/to/raster-image.tif")
newInputDf <- addRow(newInputDf, newInputRow)

# View the new inputs
newInputDf
```

```{r, warning = FALSE, echo = FALSE}
# Create input data and add it to the input datasheet
newInputDf <- data.frame(
  mMean = 2, mSD = 8,
  InterceptRasterFileName = "C:\\gitprojects\\helloworldEnhanced\\step5_Spatial\\input-raster.tif")
```

Finally, we will save the updated datasheet using `saveDatasheet()`.

```{r, warning = FALSE}
saveDatasheet(ssimObject = myNewScenario, data = newInputDf,
              name = "helloworldEnhanced_InputDatasheet")
```

## Run a model

### Setting run parameters with `run()`

We will now run our scenarios using the `run()` function in `rsyncrosim`, starting with the first scenario we created ("My first scenario").

```{r, warning = FALSE}
# Run the first scenario we created
myResultScenario <- run(myScenario)

# Check class of myResultScenario
class(myResultScenario)
```

If we have a large model and we want to parallelize the run using multiprocessing, we can set the `jobs` argument to be a value greater than 1. The following code will not work in this case since helloworldEnhanced only uses 1 multiprocessor, but it will work for most other packages.

```{r, warning = FALSE, eval = FALSE}
# Set jobs > 1 for multiprocessing - Not Run
myResultsScenario <- run(myScenario, jobs = 6)
```

Another useful argument of the `run()` function is `summary`. When set to `TRUE` it will return results scenario IDs rather than results scenario objects. By default, it is set to `FALSE`.

```{r, warning = FALSE}
# Run the first scenario we created with summary = TRUE
myResultScenario <- run(myScenario, summary = TRUE)

# Check class of myResultScenario
class(myResultScenario)
```

*The helloworldEnhanced package has a pipeline of models, in which the output of the first model (transformer) becomes the input of the second model (transformer). We can specify the `transformerName` argument if we only want to run the first model (transformer).* - This isn't true, what does the transformerName argument do??? 

```{r, warning = FALSE, eval = FALSE}
# Run the first scenario we created with only the first model
myResultScenarioModel1 <- run(myScenario, transformerName = "First Model")
```

We can also tell SyncroSim to run all the scenarios in our project at once. Instead of passing a single scenario to the `run()` function, we will tell `run()` which project to use and include a vector of scenarios.

```{r, warning = FALSE}
# Run all scenarios
myResultScenarioAll <- run(myProject,
                           scenario = c("My first scenario",
                                        "My second scenario"))
```

### Checking the run log with `runLog()`

For more information use the `runLog()` function, in which the only argument is the result scenario variable.

```{r, warning = FALSE}
# Get run details for each of our result scenarios
runLog(myResultScenarioAll[[1]])
runLog(myResultScenarioAll[[2]])
```

### Backing up run results with `backup()`

Once you have finished running your models, you may want to back up the results into a zipped .backup subfolder. First, we want to modify the Library Backup Datasheet to allow the backup of model outputs. Since this Datasheet is part of the built-in SyncroSim core, the name of the Datasheet has the prefix "core".

```{r, warning = FALSE}
# Get the current values for the Library's Backup Datasheet
sheetData <- datasheet(myLibrary, name = "core_Backup")   

# View current values for the Library's Backup Datasheet
sheetData

# Add output to the Library's Backup Datasheet and save
sheetData$IncludeOutput <- TRUE 
saveDatasheet(myLibrary, data = sheetData, name = "core_Backup")

# Check to make sure IncludeOutput is now TRUE
datasheet(myLibrary, "core_Backup")
```

Now, you can use the `backup()` function from `rsyncrosim` to backup a Library, Project, or Scenario.

```{r, warning = FALSE, eval = FALSE}
backup(myLibrary)
```


## View results


### Viewing non-spatial results with `datasheet()`

The next step is to view the result scenarios. We can load the result tables using the `datasheet()` function.


```{r, warning = FALSE}
# Results of first scenario, first model of first model in pipeline
resultsSummary <- datasheet(myResultScenarioAll[[1]],
                            name = "helloworldEnhanced_IntermediateDatasheet")

# View results table of first model in pipeline
head(resultsSummary)

# Results of first scenario, second model in pipeline
resultsSummary2 <- datasheet(myResultScenarioAll[[1]],
                             name = "helloworldEnhanced_OutputDatasheet")

# View results table of second model in pipeline
head(resultsSummary2)
```

### Viewing spatial results with `datasheetRaster()`

For spatial results, we want to load the results as raster images. To do this, we will use the `datasheetRaster()` function from `rsyncrosim`. The results contain many raster images, since we have a raster for each combination of iteration and timestep. We can use the `iteration` and `timestep` arguments to specify a single raster image or a subset of raster images we want to view. Since we have multiple parent scenarios, we also need to specify the parent scenario using the `scenario` argument.

```{r, warning = FALSE}
# Load raster files for first result scenario with timestep and iteration
rasterMaps <- datasheetRaster(
  myResultScenarioAll,
  scenario = "My second scenario",
  datasheet = "helloworldEnhanced_IntermediateDatasheet",
  column = "InterceptRasterFileName",
  iteration = 1,
  timestep = 5
  )

# View results
rasterMaps
plot(rasterMaps[[1]])
```

### Identifying the parent scenario of a result scenario using `parentId()`

If you have many alternative scenarios and many results scenarios, you can always find the parent scenario that led to a result scenario using the `rsyncrosim` function `parentId()`.

```{r, warning = FALSE}
parentId(myResultScenarioAll[[1]])
parentId(myResultScenarioAll[[2]])
```


## Access model metadata


### Getting library information using `info()`

Retrieve library information:
  
```{r, warning = FALSE}
info(myLibrary)
```

### Getting the name of a ssimObject using `name()`

Find the name of a Library, Project, or Scenario:

```{r, warning = FALSE}
name(myLibrary)
name(myProject)
name(myScenario)
```

You can also use this function to assign new names:

```{r, warning = FALSE}
name(myScenario) <- "My 1st scenario"
name(myScenario)
```

### Retrieve ID of a ssimObject using `projectId()` and `scenarioId()`

Find the project identification number:

```{r, warning = FALSE}
projectId(myProject)
```

Find the scenario identification number:

```{r, warning = FALSE}
scenarioId(myScenario)
```


### Getting the owner of a ssimObject using `owner()`

Find the owner of a Library, Project, or Scenario:

```{r, warning = FALSE}
owner(myLibrary)
owner(myProject)
owner(myScenario)
```

Can also be used to assign a new owner:

```{r, warning = FALSE}
owner(myScenario) <- "Me"
owner(myScenario)
```

### Find last date modified using `dateModified()`

Find when the last changes were made to a Library, Project, or Scenario:

```{r, warning = FALSE}
dateModified(myLibrary)
dateModified(myProject)
dateModified(myScenario)
```

### Determine read-only status using `readOnly()`

Get information about whether a Library, Project, or Scenario is read-only:

```{r, warning = FALSE}
readOnly(myLibrary)
readOnly(myProject)
readOnly(myScenario)
```

You can also set the read-only status if you don't want future users of your model to be able to change values (takes logical values):

```{r, warning = FALSE}
readOnly(myScenario) <- TRUE
readOnly(myScenario)

# Return to original status
readOnly(myScenario) <- FALSE
```

### Identify a library's package using `basePackage()`

The `basePackage()` function in `rsyncrosim` will return the name, description, and version of the package a library belongs to. It can also be used similarly to the `package()` function to find all packages that have been loaded in a session (however `package()` differs as it cannot take a `ssimObject` as an argument).

```{r, warning = FALSE}
# Find all packages that have been loaded in this session
basePackage()

# Find the package that our library belongs to
basePackage(myLibrary)
```

### Find location of ssimObject using `filepath()`

Use this function to find where a Library, Project, or Scenario is stored on your local computer.

```{r, warning = FALSE}
filepath(myLibrary)
filepath(myProject)
filepath(myScenario)
```


### View or edit ssimObject descriptions using `description()`

If we plan to add more scenarios to our project over time, we may want to add a description to each scenario. We can add descriptions to any `ssimObject` using the `description()` function from `rsyncrosim`.

```{r, warning = FALSE}
# Assign a description to your new scenario
description(myScenario) <- "A simple helloworld scenario"

# Read description of your new scenario
description(myScenario)
```

## Backup your Library

Once you have finished running your models, you may want to back up the results into a zipped .backup subfolder. First, we want to modify the Library Backup Datasheet to allow the backup of model outputs. Since this Datasheet is part of the built-in SyncroSim core, the name of the Datasheet has the prefix "core".

```{r, warning = FALSE}
# Get the current values for the Library's Backup Datasheet
sheetData <- datasheet(myLibrary, name = "core_Backup")   

# View current values for the Library's Backup Datasheet
sheetData

# Add output to the Library's Backup Datasheet and save
sheetData$IncludeOutput <- TRUE 
saveDatasheet(myLibrary, data = sheetData, name = "core_Backup")

# Check to make sure IncludeOutput is now TRUE
datasheet(myLibrary, "core_Backup")
```

Now, you can use the `backup()` function from `rsyncrosim` to backup a Library, Project, or Scenario.

```{r, warning = FALSE, eval = FALSE}
backup(myLibrary)
```
