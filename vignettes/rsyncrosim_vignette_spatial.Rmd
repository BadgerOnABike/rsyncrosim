---
title: "`rsyncrosim`: introduction to spatial data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{`rsyncrosim`: introduction to spatial data}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
params:
  EVAL: !r identical(Sys.getenv("NOT_CRAN"), "true")
---

This vignette will cover incorporating spatial data into SyncroSim models using the `rsyncrosim` package within the <a href="https://syncrosim.com/" target="_blank">SyncroSim</a> software framework. For an overview of <a href="https://syncrosim.com/" target="_blank">SyncroSim</a> and <a href="https://cran.r-project.org/web/packages/rsyncrosim/index.html" target="_blank">`rsyncrosim`</a>, as well as a basic usage tutorial for `rsyncrosim`, see the [Introduction to `rsyncrosim`](https://syncrosim.github.io/rsyncrosim/rsyncrosim_vignette_basic.html) vignette. To learn how to use iterations in the `rsyncrosim` interface, see the [`rsyncrosim`: introduction to uncertainty](https://syncrosim.github.io/rsyncrosim/rsyncrosim_vignette_uncertainty.html) vignette. To learn how to link models using pipelines in the `rsyncrosim` interface, see the [`rsyncrosim`: introduction to pipelines](https://syncrosim.github.io/rsyncrosim/rsyncrosim_vignette_pipelines.html) vignette.


## SyncroSim Package: helloworldSpatial


To demonstrate how to use spatial data in the `rsyncrosim` interface, we will be using the <a href="https://github.com/ApexRMS/helloworldSpatial" target="_blank">helloworldSpatial</a> SyncroSim package. `helloworldSpatial` was designed to be a simple package to show off some key functionalities of SyncroSim, including the ability to use both spatial and non-spatial data.

The package takes 3 inputs, *mMean*, *mSD*, and a spatial raster file of intercept (*b*) values. For each iteration, a value *m*, representing the slope, is sampled from a normal distribution with mean of *mMean* and standard deviation of *mSD*. These values are run through 2 models to produce both spatial and non-spatial outputs.

![Infographic of helloworldSpatial package](./infographic.png)

For more details on the different features of the `helloworldSpatial` SyncroSim package, consult the SyncroSim <a href="https://docs.syncrosim.com/how_to_guides/package_create_spatial.html" target="_blank">Enhancing a Package: Integrating Spatial Data</a> tutorial.


## Setup


### Install SyncroSim

Before using `rsyncrosim` you will first need to <a href="https://syncrosim.com/download/" target="_blank">download and install</a> the SyncroSim software. Versions of SyncroSim exist for both Windows and Linux.

### Installing and loading R packages

You will need to install the `rsyncrosim` R package, either using <a href="https://cran.r-project.org/" target="_blank">CRAN</a> or from the `rsyncrosim` <a href="https://github.com/syncrosim/rsyncrosim/releases/" target="_blank">GitHub repository</a>. Versions of `rsyncrosim` are available for both Windows and Linux. You may need to install the `raster` and `rgdal` packages from CRAN as well.

In a new R script, load the necessary packages. This includes the `rsyncrosim` and `raster` R packages.

```{r load packages}
# Load R packages
library(rsyncrosim)  # package for working with SyncroSim
library(raster)      # package for working with raster data
```

### Installing SyncroSim packages using `addPackage()`

Check if the <a href="https://github.com/ApexRMS/helloworldSpatial" target="_blank">helloworldSpatial</a> package is already installed. Use the `package()` function from `rsyncrosim` to first get a list of all currently installed packages in SyncroSim.

```{r delete SyncroSim packages, echo = FALSE, results = FALSE, message = FALSE}
installedPackages <- package()
if (is.element("demosales", installedPackages$name)) removePackage("demosales", force = TRUE)
if (is.element("dgsim", installedPackages$name)) removePackage("dgsim", force = TRUE)
if (is.element("epi", installedPackages$name)) removePackage("epi", force = TRUE)
if (is.element("helloworld", installedPackages$name)) removePackage("helloworld", force = TRUE)
if (is.element("helloworldEnhanced", installedPackages$name)) removePackage("helloworldEnhanced", force = TRUE)
if (is.element("helloworldTime", installedPackages$name)) removePackage("helloworldTime", force = TRUE)
if (is.element("helloworldUncertainty", installedPackages$name)) removePackage("helloworldUncertainty", force = TRUE)
if (is.element("helloworldPipeline", installedPackages$name)) removePackage("helloworldPipeline", force = TRUE)
if (is.element("helloworldSpatial", installedPackages$name)) removePackage("helloworldSpatial", force = TRUE)
if (is.element("landfirevegmodels", installedPackages$name)) removePackage("landfirevegmodels", force = TRUE)
if (is.element("stsim", installedPackages$name)) removePackage("stsim", force = TRUE)
if (is.element("stsimsf", installedPackages$name)) removePackage("stsimsf", force = TRUE)
```


```{r check packages 1, warning = FALSE}
# Get list of installed packages
package()
```

Currently we do not have the `helloworldSpatial` package installed! Install `helloworldSpatial` using the `rynscrosim` function `addPackage()`. This function takes a package name as input and then queries the SyncroSim package server for the specified package.

```{r add package from server, warning = FALSE}
# Install helloworldSpatial
addPackage("helloworldSpatial")
```

Now `helloworldSpatial` should now be included in the package list:

```{r check packages 2, warning = FALSE}
# Get list of installed packages
package()
```


*Note:* you can also update installed packages using the `updatePackage()` function or delete installed packages using the `removePackage()` function in `rsyncrosim`

### Connecting R to SyncroSim using `session()`

Connect to your installed copy of the SyncroSim software using `session()`. The first argument is a path to the folder on your computer where SyncroSim has been installed. If the first argument is left blank, then the default install folder is used (Windows only).

```{r load session not run, warning = FALSE, eval = FALSE}
mySession <- session("path/to/install_folder")      # Create a Session based SyncroSim install folder
mySession <- session()                              # Using default install folder (Windows only)
mySession                                           # Displays the Session object
```

```{r load session run, warning = FALSE, eval = TRUE, echo = FALSE}
# Results of this code shown for above
mySession <- session()                              # Using default install folder (Windows only)
mySession                                           # Displays the Session object
```

You can check to see which version of SyncroSim your R script is connected to by running the `version()` function.

```{r check version, warning = FALSE}
version(mySession)
```


## Create a modeling workflow


When creating a new modeling workflow from scratch, we need to create objects of the following scopes:

* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Library</a>
* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Projects</a>
* <a href="https://docs.syncrosim.com/how_to_guides/library_overview.html" target="_blank">Scenarios</a>

For more information on these scopes, see the [Introduction to `rsyncrosim`](https://syncrosim.github.io/rsyncrosim/rsyncrosim_vignette_basic.html) vignette.

### Set up Library, Project, and Scenario

```{r create Library, warning = FALSE}
# Create a new Library
myLibrary <- ssimLibrary(name = "helloworldLibrary.ssim",
                         session = mySession,
                         package = "helloworldSpatial",
                         overwrite = TRUE)

# Open the default Project
myProject = project(ssimObject = myLibrary, project = "Definitions")

# Create a new Scenario (associated with the default Project)
myScenario = scenario(ssimObject = myProject, scenario = "My first scenario")
```

### View model inputs using `datasheet()`
  
View the Datasheets associated with your new Scenario using the `datasheet()` function from `rsyncrosim`.

```{r view datasheet list, warning = FALSE, eval = FALSE}
# View all Datasheets associated with a library, project, or scenario
datasheet(myScenario)
```

From the list of Datasheets above, we can see that there are 4 Datasheets specific to the `helloworldPipeline` package, including an Input Datasheet, an Intermediate Datasheet, an Output Datasheet, and a Run Control Datasheet.

### Configure model inputs using `datasheet()` and `addRow()`

Currently our input Scenario Datasheets are empty! We need to add some values to our input Datasheet (`InputDatasheet`) so we can run our model. First, assign the input Datasheet to a new data frame variable.

Currently our input Scenario Datasheets are empty! We need to add some values to our input Datasheet (`InputDatasheet`) so we can run our model. First, assign the Input Datasheet to a new data frame variable, then check the columns that need input values. We can assign the input Datasheet to an R data frame using the `datasheet()` function in `rsyncrosim`.

```{r assign input data, warning = FALSE}
# Assign input Datasheet to a new data frame variable
myInputDataframe <- datasheet(myScenario,
                              name = "helloworldSpatial_InputDatasheet")

# Check the columns of the input data frame
str(myInputDataframe)
```

Notice that the type of the `InterceptRasterFileName` is a character. This is because it is a file path to an external file.

The input Datasheet requires 3 values:

* `mMean` : the mean of a normal distribution that will determine the slope of the linear equation.
* `mSD` : the standard deviation of a normal distribution that will determine the slope of the linear equation.
* `InterceptRasterFileName` : the file path to a raster image, in which each cell of the image will be an intercept in the linear equation.

We can add these values to a new data frame, then use the `addRow()` function from `rsyncrosim` to update the input Datasheet. The `addRow()` function takes the `targetDataframe` as the first value (in this case, our input Datasheet that we want to update), and the new rows to append to this data frame as the second value.

```{r add input data not run, warning = FALSE, eval = FALSE}
# Create input data and add it to the input data frame
myInputRow <- data.frame(mMean = 0, mSD = 4,
                         InterceptRasterFileName = "path/to/raster-image.tif")
myInputDataframe <- addRow(myInputDataframe, myInputRow)

# Check values
myInputDataframe
```

```{r add input data run, warning = FALSE, eval = FALSE, echo = FALSE, results = FALSE}
# Create input data and add it to the input data frame
myInputDataframe <- data.frame(
  mMean = 0, mSD = 4,
  InterceptRasterFileName = here::here("vignettes", "input-raster.tif"))
```

### Saving modifications to Datasheets using `saveDatasheet()`

Now that we have added values to the input Datasheet, we will save our updated Datasheet to the Library, Project, and/or Scenario using the `saveDatasheet()` function.

```{r save input data, warning = FALSE, eval = FALSE}
# Save input R data frame as a SyncroSim Datasheet
saveDatasheet(ssimObject = myScenario, data = myInputDataframe,
              name = "helloworldSpatial_InputDatasheet")
```

### Configuring values for the remaining Datasheets

There are a couple other Datasheets that we need to configure for our package to run. First, the `RunControl` Datasheet provides information about how many time steps and iterations to use. Second, the `Pipeline` Datasheet from the built-in SyncroSim Core specifies which models (i.e. SyncroSim Transformers) should be run in which order.

**`RunControl` Datasheet**

We need to set the number of iterations and the minimum and maximum time steps for our model. We'll add this information to an R data frame as well and then add it to the Run Control Datasheet using `addRow()`. We need to specify data for the following 4 columns:

* `MinimumIteration` : starting value of iterations (default=1).
* `MaximumIteration` : total number of iterations to run the model for.
* `MinimumTimestep` : the starting time point of the simulation.
* `MaximumTimestep` : the end time point of the simulation.

```{r modify run control, eval = FALSE}
# Assign run control Datasheet to a new data frame variable
runSettings <- datasheet(myScenario, name = "helloworldSpatial_RunControl")

# Check the columns of the run control data frame
str(runSettings)

# Create run control data and add it to the run control data frame
runSettingsRow <- data.frame(MinimumIteration = 1,
                             MaximumIteration = 5,
                             MinimumTimestep = 1,
                             MaximumTimestep = 10)
runSettings <- addRow(runSettings, runSettingsRow)

# Check values
runSettings

# Save run control R data frame as a SyncroSim Datasheet
saveDatasheet(ssimObject = myScenario, data = runSettings,
              name = "helloworldSpatial_RunControl")
```

**`Pipeline` Datasheet**

Finally, we need to specify the order in which to run the two models in our Pipeline by editing the Pipeline Datasheet. The Pipeline Datasheet is part of the built-in SyncroSim core. To access the core datasheets, we must add the argument `summary = "CORE"`. From viewing the structure of the Pipeline Datasheet we know that the `StageNameID` is a factor with 2 levels: "First Model" and "Second Model". We will set the data for this Datasheet such that "First Model" is run first, and then "Second Model".

```{r modify pipeline, eval = FALSE}
# Assign Pipeline Datasheet to a new data frame variable
myPipelineDataframe <- datasheet(myScenario, name = "core_Pipeline",
                                 summary = "CORE")

# Check the columns of the Pipeline data frame
str(myPipelineDataframe)

# Create Pipeline data and add it to the Pipeline data frame
myPipelineRow <- data.frame(StageNameID = c("First Model", "Second Model"),
                            RunOrder = c(1, 2))

myPipelineDataframe <- addRow(myPipelineDataframe, myPipelineRow)

# Check values
myPipelineDataframe

# Save Pipeline R data frame as a SyncroSim Datasheet
saveDatasheet(ssimObject = myScenario, data = myPipelineDataframe,
              name = "core_Pipeline")
```


## Edit Scenarios


You may want to test multiple alternative scenarios that have slightly different inputs. To save time, you can copy a scenario that you've already made, give it a different name, and modify the inputs. To copy a completed scenario, use the `scenario()` function with the `sourceScenario` argument set to the name of the scenario you want to copy.

```{r create new scenario from source, warning = FALSE, eval = FALSE}
# Check which scenarios you currently have in your library
scenario(myLibrary)['name']

# Create a new scenario based off an old scenario
myNewScenario <- scenario(ssimObject = myProject,
                          scenario = "My second scenario",
                          sourceScenario = myScenario)

# Make sure this new scenario has been added to the library
scenario(myLibrary)['name']
```


To edit the new scenario, we must first load the Datasheet and assign it to a new variable using the `datasheet()` function. We will set the `empty` argument to `TRUE` so that instead of getting the values from the old scenario, we can add a data frame of new values.

```{r load input data from new scenario, warning = FALSE, eval = FALSE}
# Load empty input Datasheets as an R data frame
myNewInputDataframe <- datasheet(myNewScenario,
                              name = "helloworldSpatial_InputDatasheet",
                              empty=TRUE)

# Check that we have an empty data frame
str(myNewInputDataframe)
```

Now, all we need to do is add our data frame of values the same way we did before, using the `addRow()` function.

```{r edit input data for new scenario not run, warning = FALSE, eval = FALSE}
# Create input data and add it to the input data frame
newInputRow <- data.frame(mMean = 2, mSD = 8,
                          InterceptRasterFileName = "path/to/raster-image.tif")
myNewInputDataframe <- addRow(myNewInputDataframe, newInputRow)

# View the new inputs
myNewInputDataframe
```

```{r edit input data for new scenario run, warning = FALSE, eval = FALSE, eval = FALSE, echo = FALSE}
# Create input data and add it to the input data frame
myNewInputDataframe <- data.frame(
  mMean = 2, mSD = 8,
  InterceptRasterFileName = here::here("vignettes", "input-raster.tif"))
```

Finally, we will save the updated data frame to a SyncroSim Datasheet using `saveDatasheet()`.

```{r save new scenario, warning = FALSE, eval = FALSE}
# Save R data frame to a SyncroSim Datasheet
saveDatasheet(ssimObject = myNewScenario, data = myNewInputDataframe,
              name = "helloworldSpatial_InputDatasheet")
```

## Run Scenarios

### Setting run parameters with `run()`

We will now run our scenarios using the `run()` function in `rsyncrosim`, starting with the first scenario we created ("My first scenario"). If we have a large model and we want to parallelize the run using multiprocessing, we can set the `jobs` argument to be a value greater than 1.

```{r run first scenario, warning = FALSE, eval = FALSE}
# Run the first scenario we created
myResultScenario <- run(myScenario, jobs = 6)
```

We can also tell SyncroSim to run all the scenarios in our project at once. Instead of passing a single scenario to the `run()` function, we will tell `run()` which project to use and include a vector of scenarios.

```{r run multiple scenarios, warning = FALSE, eval = FALSE}
# Run all scenarios
myResultScenarioAll <- run(myProject,
                           scenario = c("My first scenario",
                                        "My second scenario"))
```

### Checking the run log with `runLog()`

For more information use the `runLog()` function, in which the only argument is the result scenario variable.

```{r get run log, warning = FALSE, eval = FALSE}
# Get run details for the first result scenario
runLog(myResultScenario)
```


## View results


### Viewing non-spatial results with `datasheet()`

The next step is to view the result scenarios. We can load the result tables using the `datasheet()` function.


```{r view results datasheets, warning = FALSE, eval = FALSE, results = FALSE}
# Results of first scenario, first model of first model in Pipeline
resultsSummary <- datasheet(myResultScenario,
                            name = "helloworldSpatial_IntermediateDatasheet")

# View results table of first model in Pipeline
head(resultsSummary)
```

```{r resultsSummary cleaned, echo = FALSE, eval = FALSE}
resultsSummary$InterceptRasterFileName <- sub(
  ".*\\\\", "", resultsSummary$InterceptRasterFileName
  )

head(resultsSummary)
```

```{r view results summary 2, warning = FALSE, eval = FALSE}
# Results of first scenario, second model in Pipeline
resultsSummary2 <- datasheet(myResultScenario,
                             name = "helloworldSpatial_OutputDatasheet")

# View results table of second model in Pipeline
head(resultsSummary2)
```



### Viewing spatial results with `datasheetRaster()`

For spatial results, we want to load the results as raster images. To do this, we will use the `datasheetRaster()` function from `rsyncrosim`. The results contain many raster images, since we have a raster for each combination of iteration and time step. We can use the `iteration` and `timestep` arguments to specify a single raster image or a subset of raster images we want to view. Since we have multiple parent scenarios, we also need to specify the parent scenario using the `scenario` argument.

```{r view results raster, warning = FALSE, eval = FALSE}
# Load raster files for first result scenario with time step and iteration
rasterMaps <- datasheetRaster(
  myResultScenarioAll,
  scenario = "My second scenario",
  datasheet = "helloworldSpatial_IntermediateDatasheet",
  column = "InterceptRasterFileName",
  iteration = 1,
  timestep = 5
  )

# View results
rasterMaps
plot(rasterMaps[[1]])
```

### Identifying the parent scenario of a result scenario using `parentId()`

If you have many alternative scenarios and many results scenarios, you can always find the parent scenario that led to a result scenario using the `rsyncrosim` function `parentId()`.

```{r get parent ID, warning = FALSE, eval = FALSE}
parentId(myResultScenarioAll[[1]])
parentId(myResultScenarioAll[[2]])
```


## Access model metadata


### Getting library information using `info()`

Retrieve library information:
  
```{r library metadata, warning = FALSE, eval = FALSE}
info(myLibrary)
```

```{r, echo = FALSE, eval = FALSE}
libInfo <- info(myLibrary)
libInfo$value[10:13] <- sub(
  ".*\\\\", "", libInfo$value[10:13]
  )
libInfo
```


### Getting information of any ssimObject

The following functions can be used to get useful information about a Library, Project, or Scenario:

* `name()` : used to retrieve or assign a name
* `owner()` : used to retrieve or assign an owner
* `dateModified()` : used to retrieve the date when the last changes were made
* `readOnly()` : used to retrieve or assign the read only status
* `filepath()` : retrieve local file path
* `description()` : retrieve or add a description

You can also find identification numbers of projects or scenarios using the following functions:

* `projectID()` : used to retrieve the project identification number
* `scenarioID()` : used to retrieve the scenario identification number

## Backup your Library

Once you have finished running your models, you may want to back up the inputs and results into a zipped .backup subfolder. First, we want to modify the Library Backup Datasheet to allow the backup of model outputs. Since this Datasheet is part of the built-in SyncroSim core, the name of the Datasheet has the prefix "core" and we must use the `summary = "CORE"` argument when loading it.

```{r backup library, warning = FALSE, eval = FALSE}
# Get the current values for the Library's Backup Datasheet
sheetData <- datasheet(myLibrary, name = "core_Backup", summary = "CORE")   

# View current values for the Library's Backup Datasheet
sheetData

# Add output to the Library's Backup Datasheet and save
sheetData$IncludeOutput <- TRUE 
saveDatasheet(myLibrary, data = sheetData, name = "core_Backup")

# Check to make sure IncludeOutput is now TRUE
datasheet(myLibrary, "core_Backup", summary = "CORE")
```

Now, you can use the `backup()` function from `rsyncrosim` to backup a Library, Project, or Scenario.

```{r, warning = FALSE, eval = FALSE}
backup(myLibrary)
```
